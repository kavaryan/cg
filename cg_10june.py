# -*- coding: utf-8 -*-
"""CG_10June.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MXbZLudKcwQpHbdQAUSyxWLfciAVXtRY

# Without LiteLLM
"""

# --- Groq key -------------------------------------------------
API_KEY = "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"
# -----------------------------------------------------------------------------

!pip -q install groq tqdm nest_asyncio

import os, re, json, random, asyncio, time, nest_asyncio, math
from tqdm import tqdm
from groq import AsyncGroq
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple
import copy

nest_asyncio.apply()

if not API_KEY or API_KEY == "paste_your_groq_api_key_here":
    raise ValueError("❌  Replace API_KEY with your actual Groq key.")
os.environ["GROQ_API_KEY"] = API_KEY

# ---------- parameters ----------
MOTIONS      = [
    "Governments should ban fossil-fuel cars by 2035.",
    "Universal basic income should replace all means-tested welfare.",
]
NUM_MATCHES  = 6          # debates per pairing × motion
SEARCH_K     = 3          # candidates per turn for prompt-based MCTS
MODEL_NAME   = "gemma2-9b-it"
SLEEP_SEC    = 2          # pause between debates (≈ 15 req/min incl. judge+score)

# MCTS Algorithm Parameters
MCTS_ITERATIONS = 20      # Reduced for faster execution
EXPLORATION_CONSTANT = 1.414  # UCB1 exploration parameter (√2)
MAX_ROLLOUT_DEPTH = 4     # Reduced depth for faster rollouts
MCTS_TEMP = 1.0          # Temperature for action selection in MCTS

random.seed(42)

client = AsyncGroq(api_key=API_KEY)

# ---------- async helper ----------
async def gchat(messages, temp=0.8, max_tok=256):
    try:
        rsp = await client.chat.completions.create(
            model       = MODEL_NAME,
            messages    = messages,
            temperature = temp,
            max_tokens  = max_tok,
        )
        return rsp.choices[0].message.content.strip()
    except Exception as e:
        print(f"API Error: {e}")
        return "I maintain my position on this important issue."

run = lambda coro: asyncio.get_event_loop().run_until_complete(coro)

# ---------- prompt builders ----------
def debater_prompt(side, motion, history=None):
    stance = "FOR" if side=="pro" else "AGAINST"
    context = ""
    if history and len(history) > 0:
        context = f"\nDebate so far:\n" + "\n".join(history[-4:])  # Last 2 exchanges

    return [
        {"role":"system", "content":
         f"You are a persuasive debater arguing {stance}:\n\"{motion}\"{context}"},
        {"role":"user",   "content":
         "Write ONE compelling sentence (≤25 words) that advances your argument."}
    ]

def scorer_prompt(sentence, side, motion, context=""):
    stance = "FOR" if side=="pro" else "AGAINST"
    return [
        {"role":"system", "content":"Rate persuasiveness 0-10; answer with one integer."},
        {"role":"user", "content":
         f"Motion: {motion}\nContext: {context}\nSentence: {sentence}\nRate for {stance} side."}
    ]

def score_sentence(sent, side, motion, context=""):
    try:
        out = run(gchat(scorer_prompt(sent, side, motion, context), temp=0, max_tok=8))
        m = re.search(r"\d+", out)
        return int(m.group()) if m else 5
    except:
        return 5

# ---------- MCTS Node Class ----------
@dataclass
class MCTSNode:
    """Node in the MCTS tree representing a game state"""
    state: List[str]
    side: str        # Which side is to move ('pro' or 'con')
    motion: str      # The debate motion
    parent: Optional['MCTSNode'] = None
    children: Dict[str, 'MCTSNode'] = field(default_factory=dict)
    visits: int = 0
    total_reward: float = 0.0
    untried_actions: List[str] = field(default_factory=list)
    is_terminal: bool = False

    def is_fully_expanded(self) -> bool:
        """Check if all possible actions have been tried"""
        # If we haven't generated actions yet, we're not expanded
        if not self.children and not self.untried_actions:
            return False
        return len(self.untried_actions) == 0

    def best_child(self, exploration_weight: float = EXPLORATION_CONSTANT) -> Optional['MCTSNode']:
        """Select best child using UCB1 formula"""
        if not self.children:
            return None

        def ucb1_score(child):
            if child.visits == 0:
                return float('inf')

            exploitation = child.total_reward / child.visits
            exploration = exploration_weight * math.sqrt(math.log(self.visits) / child.visits)
            return exploitation + exploration

        return max(self.children.values(), key=ucb1_score)

    def update(self, reward: float):
        """Backpropagate reward up the tree"""
        self.visits += 1
        self.total_reward += reward
        if self.parent:
            # Flip reward for opponent
            self.parent.update(-reward)

    def add_child(self, action: str, child_state: List[str], child_side: str) -> 'MCTSNode':
        """Add a new child node"""
        child = MCTSNode(
            state=child_state,
            side=child_side,
            motion=self.motion,
            parent=self
        )
        self.children[action] = child
        if action in self.untried_actions:
            self.untried_actions.remove(action)
        return child

# ---------- MCTS Algorithm Implementation ----------
class MCTSDebater:
    """True MCTS algorithm implementation for debate"""

    def __init__(self, side: str, motion: str, iterations: int = MCTS_ITERATIONS):
        self.side = side
        self.motion = motion
        self.iterations = iterations

    def generate_candidate_actions(self, state: List[str], num_candidates: int = 3) -> List[str]:
        """Generate candidate debate responses"""
        candidates = []
        for attempt in range(num_candidates * 2):  # Try more attempts
            try:
                response = run(gchat(
                    debater_prompt(self.side, self.motion, state),
                    temp=1.2,
                    max_tok=40
                ))
                if response and response not in candidates and len(response.strip()) > 0:
                    candidates.append(response.strip())
                    if len(candidates) >= num_candidates:
                        break
            except Exception as e:
                continue

        # Ensure we have at least one candidate
        if not candidates:
            candidates = ["I maintain my position on this important issue."]

        return candidates

    def evaluate_state(self, state: List[str]) -> float:
        """Evaluate the current debate state from this side's perspective"""
        if len(state) == 0:
            return 0.0

        try:
            # Get the most recent statement
            if len(state) > 0:
                last_statement = state[-1]
                # Remove the "A: " or "B: " prefix
                clean_statement = re.sub(r'^[AB]: ', '', last_statement)

                # Determine if this was our statement
                last_index = len(state) - 1
                is_our_statement = (last_index % 2 == 0 and self.side == "pro") or (last_index % 2 == 1 and self.side == "con")

                if is_our_statement:
                    # Score our statement
                    context = "\n".join(state[-4:]) if len(state) > 4 else "\n".join(state)
                    score = score_sentence(clean_statement, self.side, self.motion, context)
                    return (score - 5.0) / 5.0  # Normalize to [-1, 1]
                else:
                    # Score opponent's statement (negatively)
                    opponent_side = "con" if self.side == "pro" else "pro"
                    context = "\n".join(state[-4:]) if len(state) > 4 else "\n".join(state)
                    score = score_sentence(clean_statement, opponent_side, self.motion, context)
                    return -(score - 5.0) / 5.0  # Negative because it's opponent's score

            return 0.0
        except:
            return 0.0

    def simulate_random_playout(self, state: List[str], current_side: str, depth: int = 0) -> float:
        """Simulate a random playout from the current state"""
        if depth >= MAX_ROLLOUT_DEPTH or len(state) >= 6:
            return self.evaluate_state(state)

        try:
            # Generate a random response for current_side
            response = run(gchat(
                debater_prompt(current_side, self.motion, state),
                temp=1.5,
                max_tok=40
            ))

            # Create new state
            side_letter = "A" if current_side == "pro" else "B"
            new_state = state + [f"{side_letter}: {response}"]
            next_side = "con" if current_side == "pro" else "pro"

            return self.simulate_random_playout(new_state, next_side, depth + 1)
        except:
            return self.evaluate_state(state)

    def select(self, node: MCTSNode) -> MCTSNode:
        """Selection phase: traverse tree using UCB1"""
        current = node
        while current is not None and not current.is_terminal and current.is_fully_expanded():
            best_child = current.best_child()
            if best_child is None:
                break
            current = best_child
        return current if current is not None else node

    def expand(self, node: MCTSNode) -> MCTSNode:
        """Expansion phase: add new child node"""
        if node.is_terminal or len(node.state) >= 6:
            node.is_terminal = True
            return node

        # Generate candidate actions if not done
        if not node.children and not node.untried_actions:
            node.untried_actions = self.generate_candidate_actions(node.state)
            if not node.untried_actions:
                node.is_terminal = True
                return node

        # Select untried action
        if node.untried_actions:
            action = node.untried_actions[0]  # Take first untried action

            # Create new state
            side_letter = "A" if node.side == "pro" else "B"
            new_state = node.state + [f"{side_letter}: {action}"]
            next_side = "con" if node.side == "pro" else "pro"

            # Add child
            child = node.add_child(action, new_state, next_side)
            return child

        return node

    def simulate(self, node: MCTSNode) -> float:
        """Simulation phase: random playout"""
        try:
            return self.simulate_random_playout(node.state, node.side)
        except:
            return 0.0

    def backpropagate(self, node: MCTSNode, reward: float):
        """Backpropagation phase: update node values"""
        node.update(reward)

    def search(self, root_state: List[str]) -> str:
        """Main MCTS search algorithm"""
        try:
            # Create root node
            root = MCTSNode(
                state=root_state,
                side=self.side,
                motion=self.motion
            )

            # Run MCTS iterations
            for iteration in range(self.iterations):
                try:
                    # Selection
                    leaf = self.select(root)
                    if leaf is None:
                        leaf = root

                    # Expansion
                    if not leaf.is_terminal and len(leaf.state) < 6:
                        leaf = self.expand(leaf)

                    # Simulation
                    reward = self.simulate(leaf)

                    # Backpropagation
                    self.backpropagate(leaf, reward)

                except Exception as e:
                    print(f"MCTS iteration {iteration} error: {e}")
                    continue

            # Return best action
            if not root.children:
                # Fallback to simple generation
                candidates = self.generate_candidate_actions(root_state, 1)
                return candidates[0] if candidates else "I maintain my position on this important issue."

            best_child = max(root.children.values(), key=lambda c: c.visits)
            # Find the action that led to this child
            for action, child in root.children.items():
                if child == best_child:
                    return action

            # Fallback
            return list(root.children.keys())[0]

        except Exception as e:
            print(f"MCTS search error: {e}")
            # Fallback to simple generation
            try:
                candidates = self.generate_candidate_actions(root_state, 1)
                return candidates[0] if candidates else "I maintain my position on this important issue."
            except:
                return "I maintain my position on this important issue."

# ---------- Judge and Scoring ----------
JUDGE_SYS = (
 "You are the sole judge of a three-round debate.\n"
 'Return JSON: {"winner":"A|B|draw","score_A":0-10,"score_B":0-10,"reason":"<20 words>"}'
)

async def judge_async(text):
    msgs=[{"role":"system","content":JUDGE_SYS},
          {"role":"user","content":text}]
    for _ in range(2):
        try:
            raw = await gchat(msgs, temp=0, max_tok=96)
            m = re.search(r"\{.*\}", raw, re.S)
            if m:
                try:
                    return json.loads(m.group())
                except:
                    pass
            msgs += [{"role":"assistant","content":raw},
                     {"role":"user","content":"Please correct to valid JSON only."}]
        except:
            continue
    return {"winner":"draw","score_A":5,"score_B":5,"reason":"parse_fail"}

judge = lambda t: run(judge_async(t))

# ---------- Agent Implementations ----------
def baseline(side, motion):
    """Original baseline agent"""
    def agent_fn(hist, turn):
        try:
            return run(gchat(debater_prompt(side, motion, hist), temp=0.9, max_tok=40))
        except:
            return "I maintain my position on this important issue."
    return agent_fn

def prompt_mcts(side, motion, k=SEARCH_K):
    """Original prompt-based MCTS (renamed for clarity)"""
    def fn(hist, turn):
        try:
            best, best_s = "", -1
            context = "\n".join(hist[-4:]) if len(hist) > 4 else "\n".join(hist)
            for _ in range(k):
                cand = run(gchat(debater_prompt(side, motion, hist), temp=1.2, max_tok=40))
                sc = score_sentence(cand, side, motion, context)
                if sc > best_s:
                    best_s, best = sc, cand
            return best if best else "I maintain my position on this important issue."
        except:
            return "I maintain my position on this important issue."
    return fn

def true_mcts(side, motion):
    """True MCTS algorithm implementation"""
    mcts_agent = MCTSDebater(side, motion)
    def fn(hist, turn):
        try:
            return mcts_agent.search(hist)
        except Exception as e:
            print(f"True MCTS error: {e}")
            return "I maintain my position on this important issue."
    return fn

# ---------- Debate Loop ----------
def play(motion, pro_bot, con_bot):
    log = []
    try:
        for turn in range(3):
            # Pro's turn
            pro_response = pro_bot(log, turn)
            log.append(f"A: {pro_response}")

            # Con's turn
            con_response = con_bot(log, turn)
            log.append(f"B: {con_response}")

        verdict = judge("\n".join(log))
        return verdict, log
    except Exception as e:
        print(f"Debate error: {e}")
        return {"winner":"draw","score_A":5,"score_B":5,"reason":"error"}, log

# ---------- Tournament ----------
rows = []
for motion in MOTIONS:
    base_pro, base_con = baseline("pro", motion), baseline("con", motion)
    prompt_mcts_pro, prompt_mcts_con = prompt_mcts("pro", motion), prompt_mcts("con", motion)
    true_mcts_pro, true_mcts_con = true_mcts("pro", motion), true_mcts("con", motion)

    PAIRS = [
        ("BASELINE vs BASELINE",     base_pro,        base_con),
        ("PROMPT-MCTS vs BASELINE",  prompt_mcts_pro, base_con),
        ("TRUE-MCTS vs BASELINE",    true_mcts_pro,   base_con),
        ("BASELINE vs PROMPT-MCTS",  base_pro,        prompt_mcts_con),
        ("BASELINE vs TRUE-MCTS",    base_pro,        true_mcts_con),
        ("TRUE-MCTS vs PROMPT-MCTS", true_mcts_pro,   prompt_mcts_con),
    ]

    for label, PRO, CON in PAIRS:
        wins = 0
        print(f"{motion[:38]}… | {label} | {NUM_MATCHES} debates")
        for i in tqdm(range(NUM_MATCHES), leave=False):
            try:
                ver, _ = play(motion, PRO, CON)
                wins += (ver["winner"] == "A")
                time.sleep(SLEEP_SEC)
            except Exception as e:
                print(f"Match {i} error: {e}")
                continue
        rows.append((motion[:38] + "…" * (len(motion) > 38), label, wins / NUM_MATCHES))

# ---------- Results ----------
print("\n===== Win-rate summary =====")
for m, l, w in rows:
    print(f"{m:<40s} {l:<25s} {w:5.1%}")

print("\nSample debate – TRUE-MCTS vs BASELINE\n" + "-" * 60)
try:
    v, smp = play(MOTIONS[0], true_mcts("pro", MOTIONS[0]), baseline("con", MOTIONS[0]))
    print("\n".join(smp))
    print("\nJudge:", v)
except Exception as e:
    print(f"Sample debate error: {e}")

# ---------- MCTS Analysis ----------
print(f"\n===== MCTS Configuration =====")
print(f"MCTS Iterations per move: {MCTS_ITERATIONS}")
print(f"Exploration Constant (C): {EXPLORATION_CONSTANT}")
print(f"Max Rollout Depth: {MAX_ROLLOUT_DEPTH}")
print(f"Candidate Actions per Node: 3")
print(f"Total API calls per TRUE-MCTS move: ~{MCTS_ITERATIONS + 15} (search + evaluation)")

"""# LiteLLM + scoring adjusted to -1 to 1 range : giving rate limit errors via litellm"""

# --- API key -------------------------------------------------
API_KEY = "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"
# -----------------------------------------------------------------------------

!pip -q install litellm tqdm nest_asyncio

import os, re, json, random, asyncio, time, nest_asyncio, math
from tqdm import tqdm
import litellm
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple
import copy

nest_asyncio.apply()


os.environ["GROQ_API_KEY"] = API_KEY

# ---------- parameters ----------
MOTIONS      = [
    "Governments should ban fossil-fuel cars by 2035.",
    "Universal basic income should replace all means-tested welfare.",
]
NUM_MATCHES  = 6          # debates per pairing × motion
SEARCH_K     = 3          # candidates per turn for prompt-based MCTS
MODEL_NAME   = "groq/gemma2-9b-it"  # Updated for LiteLLM
SLEEP_SEC    = 2          # pause between debates (≈ 15 req/min incl. judge+score)

# MCTS Algorithm Parameters
MCTS_ITERATIONS = 20      # Reduced for faster execution
EXPLORATION_CONSTANT = 1.414  # UCB1 exploration parameter (√2)
MAX_ROLLOUT_DEPTH = 4     # Reduced depth for faster rollouts
MCTS_TEMP = 1.0          # Temperature for action selection in MCTS

random.seed(42)

# ---------- async helper ----------
async def gchat(messages, temp=0.8, max_tok=256):
    try:
        rsp = await litellm.acompletion(
            model       = MODEL_NAME,
            messages    = messages,
            temperature = temp,
            max_tokens  = max_tok,
        )
        return rsp.choices[0].message.content.strip()
    except Exception as e:
        print(f"API Error: {e}")
        return "I maintain my position on this important issue."

run = lambda coro: asyncio.get_event_loop().run_until_complete(coro)

# ---------- prompt builders ----------
def debater_prompt(side, motion, history=None):
    stance = "FOR" if side=="pro" else "AGAINST"
    context = ""
    if history and len(history) > 0:
        context = f"\nDebate so far:\n" + "\n".join(history[-4:])  # Last 2 exchanges

    return [
        {"role":"system", "content":
         f"You are a persuasive debater arguing {stance}:\n\"{motion}\"{context}"},
        {"role":"user",   "content":
         "Write ONE compelling sentence (≤25 words) that advances your argument."}
    ]

def scorer_prompt(sentence, side, motion, context=""):
    stance = "FOR" if side=="pro" else "AGAINST"
    return [
        {"role":"system", "content":"Rate persuasiveness from -1 to 1; answer with one decimal number. -1 is completely unpersuasive, 0 is neutral/acceptable, 1 is extremely persuasive."},
        {"role":"user", "content":
         f"Motion: {motion}\nContext: {context}\nSentence: {sentence}\nRate for {stance} side."}
    ]

def score_sentence(sent, side, motion, context=""):
    try:
        out = run(gchat(scorer_prompt(sent, side, motion, context), temp=0, max_tok=8))
        # Extract decimal number from response
        m = re.search(r"-?[01](?:\.\d+)?", out)
        if m:
            score = float(m.group())
            # Clamp to [-1, 1] range
            return max(-1.0, min(1.0, score))
        return 0.0  # Default to neutral/acceptable
    except:
        return 0.0

# ---------- MCTS Node Class ----------
@dataclass
class MCTSNode:
    """Node in the MCTS tree representing a game state"""
    state: List[str]
    side: str        # Which side is to move ('pro' or 'con')
    motion: str      # The debate motion
    parent: Optional['MCTSNode'] = None
    children: Dict[str, 'MCTSNode'] = field(default_factory=dict)
    visits: int = 0
    total_reward: float = 0.0
    untried_actions: List[str] = field(default_factory=list)
    is_terminal: bool = False

    def is_fully_expanded(self) -> bool:
        """Check if all possible actions have been tried"""
        # If we haven't generated actions yet, we're not expanded
        if not self.children and not self.untried_actions:
            return False
        return len(self.untried_actions) == 0

    def best_child(self, exploration_weight: float = EXPLORATION_CONSTANT) -> Optional['MCTSNode']:
        """Select best child using UCB1 formula"""
        if not self.children:
            return None

        def ucb1_score(child):
            if child.visits == 0:
                return float('inf')

            exploitation = child.total_reward / child.visits
            exploration = exploration_weight * math.sqrt(math.log(self.visits) / child.visits)
            return exploitation + exploration

        return max(self.children.values(), key=ucb1_score)

    def update(self, reward: float):
        """Backpropagate reward up the tree"""
        self.visits += 1
        self.total_reward += reward
        if self.parent:
            # Flip reward for opponent
            self.parent.update(-reward)

    def add_child(self, action: str, child_state: List[str], child_side: str) -> 'MCTSNode':
        """Add a new child node"""
        child = MCTSNode(
            state=child_state,
            side=child_side,
            motion=self.motion,
            parent=self
        )
        self.children[action] = child
        if action in self.untried_actions:
            self.untried_actions.remove(action)
        return child

# ---------- MCTS Algorithm Implementation ----------
class MCTSDebater:
    """True MCTS algorithm implementation for debate"""

    def __init__(self, side: str, motion: str, iterations: int = MCTS_ITERATIONS):
        self.side = side
        self.motion = motion
        self.iterations = iterations

    def generate_candidate_actions(self, state: List[str], num_candidates: int = 3) -> List[str]:
        """Generate candidate debate responses"""
        candidates = []
        for attempt in range(num_candidates * 2):  # Try more attempts
            try:
                response = run(gchat(
                    debater_prompt(self.side, self.motion, state),
                    temp=1.2,
                    max_tok=40
                ))
                if response and response not in candidates and len(response.strip()) > 0:
                    candidates.append(response.strip())
                    if len(candidates) >= num_candidates:
                        break
            except Exception as e:
                continue

        # Ensure we have at least one candidate
        if not candidates:
            candidates = ["I maintain my position on this important issue."]

        return candidates

    def evaluate_state(self, state: List[str]) -> float:
        """Evaluate the current debate state from this side's perspective"""
        if len(state) == 0:
            return 0.0

        try:
            # Get the most recent statement
            if len(state) > 0:
                last_statement = state[-1]
                # Remove the "A: " or "B: " prefix
                clean_statement = re.sub(r'^[AB]: ', '', last_statement)

                # Determine if this was our statement
                last_index = len(state) - 1
                is_our_statement = (last_index % 2 == 0 and self.side == "pro") or (last_index % 2 == 1 and self.side == "con")

                if is_our_statement:
                    # Score our statement (already in [-1, 1] range)
                    context = "\n".join(state[-4:]) if len(state) > 4 else "\n".join(state)
                    score = score_sentence(clean_statement, self.side, self.motion, context)
                    return score
                else:
                    # Score opponent's statement (negatively)
                    opponent_side = "con" if self.side == "pro" else "pro"
                    context = "\n".join(state[-4:]) if len(state) > 4 else "\n".join(state)
                    score = score_sentence(clean_statement, opponent_side, self.motion, context)
                    return -score  # Negative because it's opponent's score

            return 0.0
        except:
            return 0.0

    def simulate_random_playout(self, state: List[str], current_side: str, depth: int = 0) -> float:
        """Simulate a random playout from the current state"""
        if depth >= MAX_ROLLOUT_DEPTH or len(state) >= 6:
            return self.evaluate_state(state)

        try:
            # Generate a random response for current_side
            response = run(gchat(
                debater_prompt(current_side, self.motion, state),
                temp=1.5,
                max_tok=40
            ))

            # Create new state
            side_letter = "A" if current_side == "pro" else "B"
            new_state = state + [f"{side_letter}: {response}"]
            next_side = "con" if current_side == "pro" else "pro"

            return self.simulate_random_playout(new_state, next_side, depth + 1)
        except:
            return self.evaluate_state(state)

    def select(self, node: MCTSNode) -> MCTSNode:
        """Selection phase: traverse tree using UCB1"""
        current = node
        while current is not None and not current.is_terminal and current.is_fully_expanded():
            best_child = current.best_child()
            if best_child is None:
                break
            current = best_child
        return current if current is not None else node

    def expand(self, node: MCTSNode) -> MCTSNode:
        """Expansion phase: add new child node"""
        if node.is_terminal or len(node.state) >= 6:
            node.is_terminal = True
            return node

        # Generate candidate actions if not done
        if not node.children and not node.untried_actions:
            node.untried_actions = self.generate_candidate_actions(node.state)
            if not node.untried_actions:
                node.is_terminal = True
                return node

        # Select untried action
        if node.untried_actions:
            action = node.untried_actions[0]  # Take first untried action

            # Create new state
            side_letter = "A" if node.side == "pro" else "B"
            new_state = node.state + [f"{side_letter}: {action}"]
            next_side = "con" if node.side == "pro" else "pro"

            # Add child
            child = node.add_child(action, new_state, next_side)
            return child

        return node

    def simulate(self, node: MCTSNode) -> float:
        """Simulation phase: random playout"""
        try:
            return self.simulate_random_playout(node.state, node.side)
        except:
            return 0.0

    def backpropagate(self, node: MCTSNode, reward: float):
        """Backpropagation phase: update node values"""
        node.update(reward)

    def search(self, root_state: List[str]) -> str:
        """Main MCTS search algorithm"""
        try:
            # Create root node
            root = MCTSNode(
                state=root_state,
                side=self.side,
                motion=self.motion
            )

            # Run MCTS iterations
            for iteration in range(self.iterations):
                try:
                    # Selection
                    leaf = self.select(root)
                    if leaf is None:
                        leaf = root

                    # Expansion
                    if not leaf.is_terminal and len(leaf.state) < 6:
                        leaf = self.expand(leaf)

                    # Simulation
                    reward = self.simulate(leaf)

                    # Backpropagation
                    self.backpropagate(leaf, reward)

                except Exception as e:
                    print(f"MCTS iteration {iteration} error: {e}")
                    continue

            # Return best action
            if not root.children:
                # Fallback to simple generation
                candidates = self.generate_candidate_actions(root_state, 1)
                return candidates[0] if candidates else "I maintain my position on this important issue."

            best_child = max(root.children.values(), key=lambda c: c.visits)
            # Find the action that led to this child
            for action, child in root.children.items():
                if child == best_child:
                    return action

            # Fallback
            return list(root.children.keys())[0]

        except Exception as e:
            print(f"MCTS search error: {e}")
            # Fallback to simple generation
            try:
                candidates = self.generate_candidate_actions(root_state, 1)
                return candidates[0] if candidates else "I maintain my position on this important issue."
            except:
                return "I maintain my position on this important issue."

# ---------- Judge and Scoring ----------
JUDGE_SYS = (
 "You are the sole judge of a three-round debate.\n"
 'Return JSON: {"winner":"A|B|draw","score_A":0-10,"score_B":0-10,"reason":"<20 words>"}'
)

async def judge_async(text):
    msgs=[{"role":"system","content":JUDGE_SYS},
          {"role":"user","content":text}]
    for _ in range(2):
        try:
            raw = await gchat(msgs, temp=0, max_tok=96)
            m = re.search(r"\{.*\}", raw, re.S)
            if m:
                try:
                    return json.loads(m.group())
                except:
                    pass
            msgs += [{"role":"assistant","content":raw},
                     {"role":"user","content":"Please correct to valid JSON only."}]
        except:
            continue
    return {"winner":"draw","score_A":5,"score_B":5,"reason":"parse_fail"}

judge = lambda t: run(judge_async(t))

# ---------- Agent Implementations ----------
def baseline(side, motion):
    """Original baseline agent"""
    def agent_fn(hist, turn):
        try:
            return run(gchat(debater_prompt(side, motion, hist), temp=0.9, max_tok=40))
        except:
            return "I maintain my position on this important issue."
    return agent_fn

def prompt_mcts(side, motion, k=SEARCH_K):
    """Original prompt-based MCTS (renamed for clarity)"""
    def fn(hist, turn):
        try:
            best, best_s = "", -2  # Changed to start from -2 since scores are now in [-1, 1]
            context = "\n".join(hist[-4:]) if len(hist) > 4 else "\n".join(hist)
            for _ in range(k):
                cand = run(gchat(debater_prompt(side, motion, hist), temp=1.2, max_tok=40))
                sc = score_sentence(cand, side, motion, context)
                if sc > best_s:
                    best_s, best = sc, cand
            return best if best else "I maintain my position on this important issue."
        except:
            return "I maintain my position on this important issue."
    return fn

def true_mcts(side, motion):
    """True MCTS algorithm implementation"""
    mcts_agent = MCTSDebater(side, motion)
    def fn(hist, turn):
        try:
            return mcts_agent.search(hist)
        except Exception as e:
            print(f"True MCTS error: {e}")
            return "I maintain my position on this important issue."
    return fn

# ---------- Debate Loop ----------
def play(motion, pro_bot, con_bot):
    log = []
    try:
        for turn in range(3):
            # Pro's turn
            pro_response = pro_bot(log, turn)
            log.append(f"A: {pro_response}")

            # Con's turn
            con_response = con_bot(log, turn)
            log.append(f"B: {con_response}")

        verdict = judge("\n".join(log))
        return verdict, log
    except Exception as e:
        print(f"Debate error: {e}")
        return {"winner":"draw","score_A":5,"score_B":5,"reason":"error"}, log

# ---------- Tournament ----------
rows = []
for motion in MOTIONS:
    base_pro, base_con = baseline("pro", motion), baseline("con", motion)
    prompt_mcts_pro, prompt_mcts_con = prompt_mcts("pro", motion), prompt_mcts("con", motion)
    true_mcts_pro, true_mcts_con = true_mcts("pro", motion), true_mcts("con", motion)

    PAIRS = [
        ("BASELINE vs BASELINE",     base_pro,        base_con),
        ("PROMPT-MCTS vs BASELINE",  prompt_mcts_pro, base_con),
        ("TRUE-MCTS vs BASELINE",    true_mcts_pro,   base_con),
        ("BASELINE vs PROMPT-MCTS",  base_pro,        prompt_mcts_con),
        ("BASELINE vs TRUE-MCTS",    base_pro,        true_mcts_con),
        ("TRUE-MCTS vs PROMPT-MCTS", true_mcts_pro,   prompt_mcts_con),
    ]

    for label, PRO, CON in PAIRS:
        wins = 0
        print(f"{motion[:38]}… | {label} | {NUM_MATCHES} debates")
        for i in tqdm(range(NUM_MATCHES), leave=False):
            try:
                ver, _ = play(motion, PRO, CON)
                wins += (ver["winner"] == "A")
                time.sleep(SLEEP_SEC)
            except Exception as e:
                print(f"Match {i} error: {e}")
                continue
        rows.append((motion[:38] + "…" * (len(motion) > 38), label, wins / NUM_MATCHES))

# ---------- Results ----------
print("\n===== Win-rate summary =====")
for m, l, w in rows:
    print(f"{m:<40s} {l:<25s} {w:5.1%}")

print("\nSample debate – TRUE-MCTS vs BASELINE\n" + "-" * 60)
try:
    v, smp = play(MOTIONS[0], true_mcts("pro", MOTIONS[0]), baseline("con", MOTIONS[0]))
    print("\n".join(smp))
    print("\nJudge:", v)
except Exception as e:
    print(f"Sample debate error: {e}")

# ---------- MCTS Analysis ----------
print(f"\n===== MCTS Configuration =====")
print(f"MCTS Iterations per move: {MCTS_ITERATIONS}")
print(f"Exploration Constant (C): {EXPLORATION_CONSTANT}")
print(f"Max Rollout Depth: {MAX_ROLLOUT_DEPTH}")
print(f"Candidate Actions per Node: 3")
print(f"Total API calls per TRUE-MCTS move: ~{MCTS_ITERATIONS + 15} (search + evaluation)")
print(f"Scoring Range: -1.0 to 1.0 (acceptable range: -0.5 to 0.5)")

